[合集 \- 数据库最新分享(75\)](https://github.com)[1\.华为云峰会2024，GaussDB扬帆出海，给世界一个更优选择02\-28](https://github.com/huaweiyun/p/18039161)[2\.预算有限，资源冗余？DWS集群缩容如何帮你解决烦劳02\-29](https://github.com/huaweiyun/p/18042671)[3\.数智融合，华为云GaussDB(for MySQL)助力企业释放数据新价值03\-01](https://github.com/huaweiyun/p/18046150)[4\.RDS for MySQL Serverless公测上线：弹性伸缩，最高可降成本超80%03\-04](https://github.com/huaweiyun/p/18051203)[5\.GaussDB跨云容灾：实现跨地域的数据库高可用能力03\-05](https://github.com/huaweiyun/p/18053335)[6\.实例详解如何构建动态SQL语句03\-05](https://github.com/huaweiyun/p/18053595)[7\.GaussDB(DWS)运维利刃：TopSQL工具解析03\-07](https://github.com/huaweiyun/p/18058819)[8\.手把手带你认识GaussDB轻量化运维管理工具03\-08](https://github.com/huaweiyun/p/18060868)[9\.守护更多女性健康，华为云GeminiDB助力美柚数据库高效稳定迁移03\-08](https://github.com/huaweiyun/p/18061074)[10\.GaussDB(DWS)集群通信：详解pooler连接池03\-11](https://github.com/huaweiyun/p/18065439)[11\.Libcomm通信库：GaussDB(DWS) 为解决建联过多的小妙招03\-12](https://github.com/huaweiyun/p/18067622)[12\.实例带你了解GaussDB数据库的LOCK TABLE03\-12](https://github.com/huaweiyun/p/18067811)[13\.RDS for MariaDB“智能DBA助手”，让运维效率嗖嗖地！03\-12](https://github.com/huaweiyun/p/18068198)[14\.实例带你了解GaussDB的索引管理03\-14](https://github.com/huaweiyun/p/18072786)[15\.详解GaussDB(DWS)中3个防过载检查项03\-18](https://github.com/huaweiyun/p/18080287)[16\.华为云数据库创新发展论坛，打造行业更优数据库底座！03\-19](https://github.com/huaweiyun/p/18082171)[17\.GaussDB(分布式)实例故障处理03\-19](https://github.com/huaweiyun/p/18082876)[18\.华为云GeminiDB新版本发布：全面支持Redis 6\.203\-20](https://github.com/huaweiyun/p/18084424)[19\.究竟什么样的数据库，才能承接RTA广告这个技术活！03\-20](https://github.com/huaweiyun/p/18084585)[20\.GaussDB(DWS) 业务高可靠的三大利器：CN RETRY、远程读、ELB03\-25](https://github.com/huaweiyun/p/18093728)[21\.走在前、做示范，苏州农商银行携华为云完成超级网银系统改造03\-25](https://github.com/huaweiyun/p/18094358)[22\.分布式数据库技术的演进和发展方向03\-26](https://github.com/huaweiyun/p/18095887)[23\.新版Redis不再“开源”，对使用者都有哪些影响？03\-27](https://github.com/huaweiyun/p/18099054)[24\.cgroup、资源池、用户的关系..涉及到GaussDB(DWS)的资源设置03\-29](https://github.com/huaweiyun/p/18103818)[25\.GeminiDB Cassandra接口新特性FLASHBACK发布：任意时间点秒级闪回04\-01](https://github.com/huaweiyun/p/18107811)[26\.探索GaussDB(DWS)湖仓融合：Hudi与元数据打通的深度解析04\-01](https://github.com/huaweiyun/p/18108324)[27\.详解数仓对象设计中序列SEQUENCE原理与应用04\-02](https://github.com/huaweiyun/p/18109883)[28\.数仓调优实战：GUC参数调优04\-07](https://github.com/huaweiyun/p/18119306)[29\.详讲openGauss 5\.0 单点企业版如何部署\_Centos7\_x8604\-08](https://github.com/huaweiyun/p/18121226)[30\.华为云GeminiDB，广告RTA的“登云梯”04\-09](https://github.com/huaweiyun/p/18123233)[31\.DTC2024，华为云数据库创新融合大发展，打造世界级数据库！04\-17](https://github.com/huaweiyun/p/18140057)[32\.GaussDB(DWS)基于Flink的实时数仓构建04\-18](https://github.com/huaweiyun/p/18142923)[33\.数仓的两种轻量级数据交换格式：json与jsonb04\-19](https://github.com/huaweiyun/p/18145941)[34\.重磅新品发布！云耀数据库HRDS，享受轻量级的极致体验04\-23](https://github.com/huaweiyun/p/18152769)[35\.“企业创新新引擎”数据库专项赋能会，让云原生技术普惠千行百业！04\-24](https://github.com/huaweiyun/p/18154509)[36\.GaussDB SQL查询语句执行过程解析04\-24](https://github.com/huaweiyun/p/18154664)[37\.详解数仓的向量化执行引擎04\-25](https://github.com/huaweiyun/p/18156802)[38\.Redis开源社区持续壮大，华为云为Valkey项目注入新的活力05\-06](https://github.com/huaweiyun/p/18174960)[39\.详解数仓的3A安全能力05\-07](https://github.com/huaweiyun/p/18176608)[40\.【GaussDB(for MySQL)】 Big IN查询优化05\-09](https://github.com/huaweiyun/p/18181368):[楚门加速器p](https://tianchuang88.com)[41\.GaussDB细粒度资源管控技术透视05\-09](https://github.com/huaweiyun/p/18182232)[42\.带你了解GaussDB SQL中的BOOLEAN表达式05\-10](https://github.com/huaweiyun/p/18183486)[43\.数仓安全：数据脱敏技术深度解析05\-10](https://github.com/huaweiyun/p/18184158)[44\.详解GaussDB(DWS)中的行执行引擎05\-11](https://github.com/huaweiyun/p/18185668)[45\.了解GaussDB SQL中CASE表达式05\-13](https://github.com/huaweiyun/p/18188774)[46\.JDBC连接openGauss6\.0和PostgreSQL16\.2性能对比05\-14](https://github.com/huaweiyun/p/18190500)[47\.MySQL 给用户添加 ALTER VIEW 的权限05\-15](https://github.com/huaweiyun/p/18193739)[48\.MySQL全文索引源码剖析之Insert语句执行过程05\-20](https://github.com/huaweiyun/p/18201367)[49\.全球厂商之最，华为17篇论文入选国际数据库顶会ICDE05\-22](https://github.com/huaweiyun/p/18205422)[50\.GeminiDB PITR，让游戏回档“进退自如”！05\-24](https://github.com/huaweiyun/p/18209868)[51\.浅析MySQL 8\.0直方图原理05\-27](https://github.com/huaweiyun/p/18214823)[52\.LLVM技术在GaussDB等数据库中的应用06\-03](https://github.com/huaweiyun/p/18228112)[53\.告别内存OOM，解决MySQL内存增长问题06\-04](https://github.com/huaweiyun/p/18230079)[54\.从数据库设计到性能调优，全面掌握openGemini应用开发最佳实践06\-04](https://github.com/huaweiyun/p/18230132)[55\.深度体验与测评openGauss 6\.0\.0新版本06\-11](https://github.com/huaweiyun/p/18241468)[56\.深度解读数据库引入LLVM技术后如何提升性能06\-12](https://github.com/huaweiyun/p/18243298)[57\.从Purge机制说起，详解GaussDB(for MySQL)的优化策略06\-17](https://github.com/huaweiyun/p/18251951)[58\.攀登不止，华为数据库论文入选SIGMOD 2024，技术创新再谱新篇06\-18](https://github.com/huaweiyun/p/18253637)[59\.技术解读数据库如何实现“多租户”？06\-20](https://github.com/huaweiyun/p/18258109)[60\.解读MySQL 8\.0数据字典的初始化与启动06\-24](https://github.com/huaweiyun/p/18264934)[61\.GeminiDB全面联动MySQL：热点数据，一键加速06\-26](https://github.com/huaweiyun/p/18268343)[62\.探秘数据库中的并行计算技术应用07\-01](https://github.com/huaweiyun/p/18277496)[63\.硬核解读，WeTune是如何提升数据库查询重写性能？07\-04](https://github.com/huaweiyun/p/18283101)[64\.开源数据库Greenplu突然闭源？GaussDB(DWS)提供数仓新可能07\-08](https://github.com/huaweiyun/p/18289386)[65\.数据库异常难定位？GaussDB(DWS)运维神器TopSQL来解决07\-10](https://github.com/huaweiyun/p/18293964)[66\.MySQL派生表合并优化的原理和实现07\-11](https://github.com/huaweiyun/p/18295374)[67\.华为云发起，openGemini正式成为CNCF官方项目！07\-11](https://github.com/huaweiyun/p/18296287)[68\.MySQL中为什么要使用索引合并(Index Merge)？07\-12](https://github.com/huaweiyun/p/18297565)[69\.解读MySQL 8\.0数据字典缓存管理机制07\-16](https://github.com/huaweiyun/p/18304461)[70\.解读GaussDB(for MySQL)灵活多维的二级分区表策略07\-19](https://github.com/huaweiyun/p/18310785)[71\.深度解读GaussDB(for MySQL)与MySQL的COUNT查询并行优化策略07\-25](https://github.com/huaweiyun/p/18322194)[72\.一图为你揭秘云数据库GaussDB管理平台亮点10\-17](https://github.com/huaweiyun/p/18472408)[73\.深度解读GaussDB逻辑解码技术原理10\-28](https://github.com/huaweiyun/p/18510534)[74\.深度解读RDS for MySQL 审计日志功能和原理10\-29](https://github.com/huaweiyun/p/18512497)75\.遇到慢查询怎么办？一文解读MySQL 8\.0查询分析工具10\-31收起
本文分享自华为云社区[《【华为云MySQL技术专栏】MySQL 8\.0 EXPLAIN ANALYZE 工具介绍》](https://github.com)，作者：GaussDB 数据库。


# 1\. EXPLAIN ANALYZE可以解决什么问题


MySQL 8\.0\.18 版本开始支持查询分析工具EXPLAIN ANALYZE，该工具不仅会实际执行SQL语句，还会展示SQL语句详细的执行信息，包含执行算子（Iterator）粒度的扫描行数、执行耗时、迭代次数等信息。


 


EXPLAIN ANALYZE工具是MySQL EXPLAIN FORMAT\=TREE 功能的扩展，除了展示执行计划和代价估算之外，还提供了细粒度执行算子的耗时等信息。这使得DBA和开发人员能够基于代价估算和算子实际执行耗时信息，判断执行计划是否合理，并识别出后续的优化点。


# 2\. EXPLAIN ANALYZE如何使用


以TPC\-H基准测试中的Q14 查询为例，该SQL为两个表的连接及GROUP BY聚合操作，用于统计发货日志在1996年1月的促销商品收入占比 。



```
select
	100.00 * sum(case
		when p_type like 'PROMO%'
			then l_extendedprice * (1 - l_discount)
		else 0
	end) / sum(l_extendedprice * (1 - l_discount)) as promo_revenue
from
	lineitem,
	part
where
	l_partkey = p_partkey
	and l_shipdate >= '1996-01-01'
	and l_shipdate < date_add( '1996-01-01', interval '1' month);
```

通过EXPLAIN FORMAT\=TREE语句，可以看出执行计划和代价估算信息：



```
-> Aggregate: sum((lineitem.L_EXTENDEDPRICE * (1 - lineitem.L_DISCOUNT))), sum((case when (part.P_TYPE like 'PROMO%') then (lineitem.L_EXTENDEDPRICE * (1 - lineitem.L_DISCOUNT)) else 0 end))
  -> Nested loop inner join (cost=83997.65 rows=66041)
      -> Filter: ((lineitem.L_SHIPDATE >= DATE'1996-01-01') and (lineitem.L_SHIPDATE < <cache>(('1996-01-01' + interval '1' month)))) (cost=60883.30 rows=66041)
          -> Table scan on lineitem (cost=60883.30 rows=594488)
      -> Single-row index lookup on part using PRIMARY (P_PARTKEY=lineitem.L_PARTKEY) (cost=0.25 rows=1)
```

通过EXPLAIN ANALYZE语句，可以看出每个算子详细的执行信息，如下:



```
-> Aggregate: sum((lineitem.L_EXTENDEDPRICE * (1 - lineitem.L_DISCOUNT))), sum((case when (part.P_TYPE like 'PROMO%') then (lineitem.L_EXTENDEDPRICE * (1 - lineitem.L_DISCOUNT)) else 0 end)) (actual time=203.753..203.753 rows=1 loops=1)
  -> Nested loop inner join (cost=83997.65 rows=66041) (actual time=0.056..200.386 rows=7884 loops=1)
      -> Filter: ((lineitem.L_SHIPDATE >= DATE'1996-01-01') and (lineitem.L_SHIPDATE < <cache>(('1996-01-01' + interval '1' month)))) (cost=60883.30 rows=66041) (actual time=0.042..183.957 rows=7884 loops=1)
          -> Table scan on lineitem (cost=60883.30 rows=594488) (actual time=0.039..140.993 rows=600572 loops=1)
      -> Single-row index lookup on part using PRIMARY (P_PARTKEY=lineitem.L_PARTKEY) (cost=0.25 rows=1) (actual time=0.002..0.002 rows=1 loops=7884)
```

相比EXPLAIN FORMAT\=TREE，EXPLAIN ANALYZE会实际执行SQL语句，并统计每个算子的详细耗时信息，每个算子额外提供如下信息：



```
(actual time=m_start..m_end rows=m_rows loops=m_loops)
```

* m\_start: 该算子返回第一行数据的实际时间(毫秒)
* m\_end: 该算子返回所有数据的实际时间(毫秒)
* m\_rows: 该算子实际的返回行数
* m\_loops: 该算子实际的迭代次数


例如，Filter算子过滤lineitem表的L\_SHIPDATE字段在 \['1996\-01\-01', '1996\-02\-01') 区间的数据。



```
Filter: ((lineitem.L_SHIPDATE >= DATE'1996-01-01') and (lineitem.L_SHIPDATE < <cache>(('1996-01-01' + interval '1' month))))
(cost=60883.30 rows=66041)
(actual time=0.042..183.957 rows=7884 loops=1)
```

优化器基于统计信息估算出的代价为 60883\.30，预测返回行数为 66041；然而，实际执行后发现，真实的返回行数为7884。其中，Filter算子过滤掉了592688行 (600572 \- 7884\)。迭代次数为1（对应于Nested Loop Join中外表的扫描次数），返回给上层算子（Nested loop inner join）第一行数据的时间为 0\.042 毫秒，返回给上层算子所有数据的时间为 183\.957 毫秒。


 


例如，点查算子Single\-row index lookup on part using PRIMARY，作为Nested loop inner join的内表，通过条件part.p\_partkey \= lineitem.l\_partkey循环获取满足条件的行。



```
Single-row index lookup on part using PRIMARY (P_PARTKEY=lineitem.L_PARTKEY)
(cost=0.25 rows=1)
(actual time=0.002..0.002 rows=1 loops=7884)
```

优化器估算出的代价为0\.25，预测返回行数为 1；然而，实际执行后发现，真实的返回行数为1，但迭代次数为7884，与外表FILTER算子执行后的结果数据量相等，每次迭代只返回上层算子1行。因此，返回给上层算子（Nested loop inner join）第一行数据的时间和所有数据的时间相等，都是0\.002毫秒，可以推算出内表点查的累计耗时为 15\.768 毫秒(7884 \* 0\.002毫秒)。


 


基于以上分析，我们可以看出该SQL语句执行耗时约200 毫秒，lineitem表的全表扫描耗时约140 毫秒，Filter算子耗时约40 毫秒，part表循环点查约16 毫秒。


# 3\. EXPLAIN ANALYZE源码实现


MySQL 8\.0 使用火山执行引擎，火山模型是数据库系统中广泛使用的迭代模型。SQL语句经过查询解析生成抽象语法树（AST），然后经过查询优化，最终生成执行树，执行树的每个节点对应一个执行算子（Iterator）。每个算子提供了Init,Read,End接口，每个算子从子节点获取数据，执行该算子的相关工作，并返回结果给父节点。


 


以MySQL 8\.0\.22版本为例，它提供了37个执行算子来处理数据读取、多表连接、聚合操作、数据物化等多个操作场景，每个执行算子都继承自一个基类RowIterator。


 


例如， TableScanIterator（处理全表扫描）和 NestedLoopIterator（处理2表连接）的类图如图1所示：


![](https://img2024.cnblogs.com/blog/2030258/202410/2030258-20241031103232821-29339864.png)


图1 TableScanIterator 和 NestedLoopIterator 类图


EXPLAIN ANALYZE 工具的作用是展示SQL语句的执行计划以及详细记录各个算子的执行耗时。在MySQL 8\.0中，这一功能的实现是通过新增一个接口模板类TimingIterator，将37个执行算子封装起来，以便统计各个执行算子的详细执行耗时信息。这样做的好处是实现简单，无需对所有算子单独适配，而且不影响非EXPLAIN ANALYZE语句的执行效率。


 


例如，全表扫描算子TableScanIterator 对应TimingIterator，表连接算子  NestedLoopIterator 对应 TimingIterator，其类图如图2所示：


![](https://img2024.cnblogs.com/blog/2030258/202410/2030258-20241031103248217-284811178.png)


图2 TimingIterator 和 TimingIterator 类图


### 3\.1 执行树生成


数据库优化器在确定了最优的访问路径(AccessPath)之后，会通过函数 CreateIteratorFromAccessPath 生成执行树，该函数会依据算子类型，调用NewIterator函数生成对应的算子。


 


如果是普通DQL(SELECT)语句，则生成对应的算子；如果是 EXPLAIN ANALYZE语句，则生成一个 TimingIteratorWapper对象，其真实执行算子被保存在 TimingIterator::m\_iterator 中。


 


例如，EXPLAIN ANALYZE语句，TableScanIterator 会生成TimingIterator 算子，NestedLoopIterator 会生成 TimingIterator 算子，执行流程如图3所示。


![](https://img2024.cnblogs.com/blog/2030258/202410/2030258-20241031103302670-777197093.png)


图3 执行树生成流程


### 3\.2 统计算子执行耗时


TimingIterator 模板类的主体实现如下表所示，执行的统计信息记录在几个私有成员变量中。



```
template <class RealIterator>
class TimingIterator final : public RowIterator {
 public:
  bool Init() override;
  int Read() override;
  std::string TimingString() const override; // 打印函数，输出算子执行时间信息

 private:
  uint64_t m_num_rows = 0; // 该算子累计处理的记录数
  uint64_t m_num_init_calls = 0; // 调用 Init 函数的次数
  // 返回第一行的执行时间
  steady_clock::time_point::duration m_time_spent_in_first_row{0}; 
  // 返回所有行的执行时间
  steady_clock::time_point::duration m_time_spent_in_other_rows{0};
  bool m_first_row; // 是否为第一行数据
  RealIterator m_iterator; // 真实的执行算子
};
```

在SQL语句实际执行过程中，通过 Init 和 Read 函数的调度来记录详细执行信息，具体实现如下:



```
template <class RealIterator>
bool TimingIterator::Init() {
  ++m_num_init_calls;  // Init 函数的调用次数递增
  steady_clock::time_point start = now();
  bool err = m_iterator.Init(); // 调用真实执行算子的Init函数
  steady_clock::time_point end = now();
  m_time_spent_in_first_row += end - start; // 累计获取第一行数据的时间
  m_first_row = true;
  return err;
}

template <class RealIterator>
int TimingIterator::Read() {
  steady_clock::time_point start = now();
  int err = m_iterator.Read(); // 调用真实执行算子的Read 函数
  steady_clock::time_point end = now();
  if (m_first_row) {
    m_time_spent_in_first_row += end - start; // 更新获取第一行数据的时间
    m_first_row = false; // 获取第一行数据结束
  } else {
    m_time_spent_in_other_rows += end - start; // 更新获取所有行数据的时间
  }
  if (err == 0) {
    ++m_num_rows; // 刷新该算子累计处理的记录数
  }
  return err;
}
```

### 3\.3 打印算子执行耗时


SQL语句执行结束后，会调用函数  TimingIterator::TimingString 打印算子执行耗时信息，调用堆栈信息如下表所示：



```
dispatch_command
  mysql_parse
    mysql_execute_command
      Sql_cmd_dml::execute
        Sql_cmd_dml::execute_inner
          explain_query
            ExplainIterator
              PrintQueryPlan
                ExplainAccessPath
                  TimingIterator::TimingString
```

TimingIterator::TimingString 函数，会基于执行阶段的统计打印以下信息：


* 该算子返回第一行数据的实际时间(毫秒)
* 该算子返回所有数据的实际时间(毫秒)
* 该算子实际的返回行数
* 该算子实际的迭代次数


# 4\. 总结


综上，我们分析了MySQL 8\.0 EXPLAIN ANALYZE命令的使用，并结合源码介绍其实现思路，帮助数据库使用者和开发者更好的使用、理解该功能。


 


当遇到慢查询时，我们也可借助于EXPLAIN ANALYZE工具观察执行计划是否合理、分析SQL执行的主要耗时点，进而去优化SQL执行。


# 参考资料


[https://dev.mysql.com/doc/relnotes/mysql/8\.0/en/news\-8\-0\-18\.html](https://github.com)


[https://dev.mysql.com/worklog/task/?id\=4168](https://github.com)


[https://dev.mysql.com/doc/refman/8\.0/en/using\-explain.html](https://github.com)




---


华为开发者空间，汇聚鸿蒙、昇腾、鲲鹏、GaussDB、欧拉等各项根技术的开发资源及工具，致力于为每位开发者提供一台云主机、一套开发工具及云上存储空间，让开发者基于华为根生态创新。[点击链接，免费领取您的专属云主机\~](https://developer.huaweicloud.com/space/devportal/desktop?utm_source=kfzwzdspace&utm_adplace=nrcbds)


 


[点击关注，第一时间了解华为云新鲜技术\~](https://github.com)


